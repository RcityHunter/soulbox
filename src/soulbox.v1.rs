// This file is @generated by prost-build.
/// Messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxRequest {
    #[prost(string, tag = "1")]
    pub template_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<SandboxConfig>,
    #[prost(map = "string, string", tag = "3")]
    pub environment_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "4")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxResponse {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub endpoint_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxConfig {
    #[prost(message, optional, tag = "1")]
    pub resource_limits: ::core::option::Option<ResourceLimits>,
    #[prost(message, optional, tag = "2")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    #[prost(string, repeated, tag = "3")]
    pub allowed_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub enable_internet: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    #[prost(uint64, tag = "1")]
    pub memory_mb: u64,
    #[prost(float, tag = "2")]
    pub cpu_cores: f32,
    #[prost(uint64, tag = "3")]
    pub disk_mb: u64,
    #[prost(uint32, tag = "4")]
    pub max_processes: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    #[prost(uint32, repeated, tag = "1")]
    pub exposed_ports: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, tag = "2")]
    pub enable_port_forwarding: bool,
    #[prost(string, tag = "3")]
    pub subnet: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSandboxRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSandboxResponse {
    #[prost(message, optional, tag = "1")]
    pub sandbox: ::core::option::Option<Sandbox>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sandbox {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub template_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<SandboxConfig>,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "7")]
    pub environment_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub endpoint_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesRequest {
    #[prost(int32, tag = "1")]
    pub page: i32,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesResponse {
    #[prost(message, repeated, tag = "1")]
    pub sandboxes: ::prost::alloc::vec::Vec<Sandbox>,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
    #[prost(int32, tag = "3")]
    pub page: i32,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSandboxRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSandboxResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteCodeRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub language: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub environment_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "5")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "6")]
    pub working_directory: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteCodeResponse {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stdout: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub stderr: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub exit_code: i32,
    #[prost(message, optional, tag = "5")]
    pub execution_time: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "6")]
    pub timed_out: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteCodeStreamResponse {
    #[prost(oneof = "execute_code_stream_response::Response", tags = "1, 2, 3, 4")]
    pub response: ::core::option::Option<execute_code_stream_response::Response>,
}
/// Nested message and enum types in `ExecuteCodeStreamResponse`.
pub mod execute_code_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Started(super::ExecutionStarted),
        #[prost(message, tag = "2")]
        Output(super::ExecutionOutput),
        #[prost(message, tag = "3")]
        Completed(super::ExecutionCompleted),
        #[prost(message, tag = "4")]
        Error(super::ExecutionError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionStarted {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionOutput {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(enumeration = "OutputType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub data: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionCompleted {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
    #[prost(message, optional, tag = "3")]
    pub execution_time: ::core::option::Option<::prost_types::Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionError {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_type: ::prost::alloc::string::String,
}
/// File operations
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileRequest {
    #[prost(oneof = "upload_file_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<upload_file_request::Request>,
}
/// Nested message and enum types in `UploadFileRequest`.
pub mod upload_file_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        Metadata(super::FileUploadMetadata),
        #[prost(bytes, tag = "2")]
        Chunk(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileUploadMetadata {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub file_size: u64,
    #[prost(string, tag = "4")]
    pub content_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadFileResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub bytes_uploaded: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadFileResponse {
    #[prost(oneof = "download_file_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<download_file_response::Response>,
}
/// Nested message and enum types in `DownloadFileResponse`.
pub mod download_file_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Metadata(super::FileDownloadMetadata),
        #[prost(bytes, tag = "2")]
        Chunk(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDownloadMetadata {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub file_size: u64,
    #[prost(string, tag = "3")]
    pub content_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub recursive: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<FileInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub size: u64,
    #[prost(bool, tag = "4")]
    pub is_directory: bool,
    #[prost(message, optional, tag = "5")]
    pub modified_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub permissions: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFileRequest {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFileResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Streaming messages
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamRequest {
    #[prost(oneof = "sandbox_stream_request::Request", tags = "1, 2, 3")]
    pub request: ::core::option::Option<sandbox_stream_request::Request>,
}
/// Nested message and enum types in `SandboxStreamRequest`.
pub mod sandbox_stream_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        Init(super::SandboxStreamInit),
        #[prost(message, tag = "2")]
        Command(super::SandboxStreamCommand),
        #[prost(message, tag = "3")]
        Data(super::SandboxStreamData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamInit {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(enumeration = "StreamType", tag = "2")]
    pub stream_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamCommand {
    #[prost(string, tag = "1")]
    pub command_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub parameters: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamData {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamResponse {
    #[prost(oneof = "sandbox_stream_response::Response", tags = "1, 2, 3")]
    pub response: ::core::option::Option<sandbox_stream_response::Response>,
}
/// Nested message and enum types in `SandboxStreamResponse`.
pub mod sandbox_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Ready(super::SandboxStreamReady),
        #[prost(message, tag = "2")]
        Output(super::SandboxStreamOutput),
        #[prost(message, tag = "3")]
        Error(super::SandboxStreamError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamReady {
    #[prost(string, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamOutput {
    #[prost(string, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "OutputType", tag = "3")]
    pub output_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxStreamError {
    #[prost(string, tag = "1")]
    pub stream_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Terminal streaming
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalStreamRequest {
    #[prost(oneof = "terminal_stream_request::Request", tags = "1, 2, 3")]
    pub request: ::core::option::Option<terminal_stream_request::Request>,
}
/// Nested message and enum types in `TerminalStreamRequest`.
pub mod terminal_stream_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        Init(super::TerminalInit),
        #[prost(message, tag = "2")]
        Input(super::TerminalInput),
        #[prost(message, tag = "3")]
        Resize(super::TerminalResize),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalInit {
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<TerminalConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalConfig {
    #[prost(uint32, tag = "1")]
    pub rows: u32,
    #[prost(uint32, tag = "2")]
    pub cols: u32,
    #[prost(string, tag = "3")]
    pub shell: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub working_directory: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub environment_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalInput {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalResize {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub rows: u32,
    #[prost(uint32, tag = "3")]
    pub cols: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalStreamResponse {
    #[prost(oneof = "terminal_stream_response::Response", tags = "1, 2, 3, 4")]
    pub response: ::core::option::Option<terminal_stream_response::Response>,
}
/// Nested message and enum types in `TerminalStreamResponse`.
pub mod terminal_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        Ready(super::TerminalReady),
        #[prost(message, tag = "2")]
        Output(super::TerminalOutput),
        #[prost(message, tag = "3")]
        Closed(super::TerminalClosed),
        #[prost(message, tag = "4")]
        Error(super::TerminalError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalReady {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalOutput {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalClosed {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalError {
    #[prost(string, tag = "1")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Health check
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckRequest {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutputType {
    Unspecified = 0,
    Stdout = 1,
    Stderr = 2,
}
impl OutputType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OutputType::Unspecified => "OUTPUT_TYPE_UNSPECIFIED",
            OutputType::Stdout => "OUTPUT_TYPE_STDOUT",
            OutputType::Stderr => "OUTPUT_TYPE_STDERR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTPUT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "OUTPUT_TYPE_STDOUT" => Some(Self::Stdout),
            "OUTPUT_TYPE_STDERR" => Some(Self::Stderr),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamType {
    Unspecified = 0,
    Terminal = 1,
    Process = 2,
    FileWatcher = 3,
}
impl StreamType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamType::Unspecified => "STREAM_TYPE_UNSPECIFIED",
            StreamType::Terminal => "STREAM_TYPE_TERMINAL",
            StreamType::Process => "STREAM_TYPE_PROCESS",
            StreamType::FileWatcher => "STREAM_TYPE_FILE_WATCHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STREAM_TYPE_TERMINAL" => Some(Self::Terminal),
            "STREAM_TYPE_PROCESS" => Some(Self::Process),
            "STREAM_TYPE_FILE_WATCHER" => Some(Self::FileWatcher),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unspecified = 0,
    Serving = 1,
    NotServing = 2,
    Unknown = 3,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HealthStatus::Unspecified => "HEALTH_STATUS_UNSPECIFIED",
            HealthStatus::Serving => "HEALTH_STATUS_SERVING",
            HealthStatus::NotServing => "HEALTH_STATUS_NOT_SERVING",
            HealthStatus::Unknown => "HEALTH_STATUS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTH_STATUS_SERVING" => Some(Self::Serving),
            "HEALTH_STATUS_NOT_SERVING" => Some(Self::NotServing),
            "HEALTH_STATUS_UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
